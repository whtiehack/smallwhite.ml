---
title: 全局异常过滤程序 以及 finally 块 演示
date: 2011-03-07 03:39:00
tags: CSDN迁移
---
   #include <WindowsX.h> #include <atlstr.h> //可以用 cstring了 #include <stdio.h> #include <locale> #include <CommCtrl.h>//windows通用控件接口 // Returns the HMODULE that contains the specified memory address static HMODULE ModuleFromAddress(PVOID pv) { MEMORY_BASIC_INFORMATION mbi; return((VirtualQuery(pv, &mbi, sizeof(mbi)) != 0) ? (HMODULE) mbi.AllocationBase : NULL); } /*********************************************************** * 创建日期: 2011/03/07 1:19 * 函数名称: * 函数功能: * 参数个数: * 返 回 值: DWORD * 作 者: SmallWhite * 备 注: ttsq.cpp ***********************************************************/ LONG WINAPI TopLevelUnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionInfo)//; //顶层异常过滤处理函数 { //全局异常过滤程序 TCHAR szBuff[1024]; HMODULE hMod=ModuleFromAddress(pExceptionInfo->ExceptionRecord->ExceptionAddress); TCHAR szMod[MAX_PATH]={0}; if (hMod!=NULL) { GetModuleFileName(hMod,szMod,sizeof(szMod)); } else { lstrcpy(szMod,TEXT("Unknow Module")); } wsprintf(szBuff,TEXT("异常产生/r/n模块:/r/n%s/r/n位置:0x%08X 相对模块偏移:0x%08X 异常代码:0x%08X/r/n寄存器:/t/tEIP:%08X/r/n/ EAX:%08X/tECX:%08X/r/nEDX:%08X/tEBX:%08X/r/nESP:%08X/tEBP:%08X/r/nESI:%08X/tEDI:%08X/r/n"), szMod,pExceptionInfo->ExceptionRecord->ExceptionAddress, (int)pExceptionInfo->ExceptionRecord->ExceptionAddress-(int)hMod, pExceptionInfo->ExceptionRecord->ExceptionCode, pExceptionInfo->ContextRecord->Eip, pExceptionInfo->ContextRecord->Eax,pExceptionInfo->ContextRecord->Ecx, pExceptionInfo->ContextRecord->Edx,pExceptionInfo->ContextRecord->Ebx, pExceptionInfo->ContextRecord->Esp,pExceptionInfo->ContextRecord->Ebp, pExceptionInfo->ContextRecord->Esi,pExceptionInfo->ContextRecord->Edi); _tprintf(szBuff); MessageBox(GetForegroundWindow(),szBuff,TEXT("Error"),0); return EXCEPTION_EXECUTE_HANDLER;//EXCEPTION_CONTINUE_SEARCH;//EXCEPTION_CONTINUE_EXECUTION;// EXCEPTION_EXECUTE_HANDLER; } //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LONG WINAPI TopLevelUnhandledExceptionFilterT(PEXCEPTION_POINTERS pExceptionInfo)//; //顶层异常过滤处理函数 { TCHAR szBuff[1024]; wsprintf(szBuff,TEXT("TT异常产生/r/n位置:0x%08X 异常代码:0x%08X/r/n"), pExceptionInfo->ExceptionRecord->ExceptionAddress,pExceptionInfo->ExceptionRecord->ExceptionCode); _tprintf(szBuff); MessageBox(GetForegroundWindow(),szBuff,TEXT("TTError"),0); return EXCEPTION_CONTINUE_SEARCH;//用 EXCEPTION_EXECUTE_HANDLER 将静默退出进程 //返回 EXCEPTION_CONTINUE_SEARCH 将交给windows 错误报告处理 } void FunError(LPVOID pParam) { int n=0; __try { n=5/n;//除0错误 } __finally { //终止程序 MessageBox(GetForegroundWindow(),TEXT("I'm finally"),TEXT("finally"),NULL); } } int main() { SetUnhandledExceptionFilter(TopLevelUnhandledExceptionFilter);//返回上次安装的异常过滤处理函数地址 //设置 全局异常过滤程序 // SetUnhandledExceptionFilter(TopLevelUnhandledExceptionFilterT);//返回上次安装的异常过滤处理函数地址 //看起来安装两次 直接被替换成 最后一次的了 _tsetlocale(LC_CTYPE, TEXT(""));//让wprintf 支持中文 _tprintf(TEXT("begin 当前Exe模块:0x%08X %d/r/n"), GetModuleHandle(NULL),IsDebuggerPresent()); _beginthread(FunError,NULL,NULL); // Sleep(1000); _tprintf(TEXT("can here?/r/n")); int nadd=0; __try { while (1) { nadd++; _tprintf(TEXT("%d/r/n"),nadd); Sleep(500); } } __finally { //终止程序 _tprintf(TEXT("main() finally/r/n")); } _tprintf(TEXT("and here?/r/n")); return 0; } 

 

 保存下咯

   
 