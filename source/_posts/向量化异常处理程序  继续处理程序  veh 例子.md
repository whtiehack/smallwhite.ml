---
title: 向量化异常处理程序  继续处理程序  veh 例子
date: 2011-03-22 13:52:00
tags: CSDN迁移
---
   继续处理程序不知为何 竟然不触发!

 

 #include <WindowsX.h> #include <atlstr.h> //可以用 cstring了 #include <stdio.h> #include <locale> #include <CommCtrl.h>//windows通用控件接口 LPTOP_LEVEL_EXCEPTION_FILTER pprev=NULL; // Returns the HMODULE that contains the specified memory address static HMODULE ModuleFromAddress(PVOID pv) { MEMORY_BASIC_INFORMATION mbi; return((VirtualQuery(pv, &mbi, sizeof(mbi)) != 0) ? (HMODULE) mbi.AllocationBase : NULL); } /*********************************************************** * 创建日期: 2011/03/07 1:19 * 函数名称: * 函数功能: * 参数个数: * 返 回 值: DWORD * 作 者: SmallWhite * 备 注: ttsq.cpp ***********************************************************/ LONG WINAPI TopLevelUnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionInfo)//; //顶层异常过滤处理函数 { //全局异常过滤程序 TCHAR szBuff[1024]; HMODULE hMod=ModuleFromAddress(pExceptionInfo->ExceptionRecord->ExceptionAddress); TCHAR szMod[MAX_PATH]={0}; if (hMod!=NULL) { GetModuleFileName(hMod,szMod,sizeof(szMod)); } else { lstrcpy(szMod,TEXT("Unknow Module")); } wsprintf(szBuff,TEXT("异常产生/r/n模块:/r/n%s/r/n位置:0x%08X 相对模块偏移:0x%08X 异常代码:0x%08X/r/n寄存器:/t/tEIP:%08X/r/n/ EAX:%08X/tECX:%08X/r/nEDX:%08X/tEBX:%08X/r/nESP:%08X/tEBP:%08X/r/nESI:%08X/tEDI:%08X/r/n"), szMod,pExceptionInfo->ExceptionRecord->ExceptionAddress, (int)pExceptionInfo->ExceptionRecord->ExceptionAddress-(int)hMod, pExceptionInfo->ExceptionRecord->ExceptionCode, pExceptionInfo->ContextRecord->Eip, pExceptionInfo->ContextRecord->Eax,pExceptionInfo->ContextRecord->Ecx, pExceptionInfo->ContextRecord->Edx,pExceptionInfo->ContextRecord->Ebx, pExceptionInfo->ContextRecord->Esp,pExceptionInfo->ContextRecord->Ebp, pExceptionInfo->ContextRecord->Esi,pExceptionInfo->ContextRecord->Edi); _tprintf(szBuff); MessageBox(GetForegroundWindow(),szBuff,TEXT("全局异常过滤程序"),0); return EXCEPTION_CONTINUE_SEARCH;//EXCEPTION_CONTINUE_SEARCH;//EXCEPTION_CONTINUE_EXECUTION;// EXCEPTION_EXECUTE_HANDLER; } //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LONG WINAPI TopLevelUnhandledExceptionFilterT(PEXCEPTION_POINTERS pExceptionInfo)//; //顶层异常过滤处理函数 { TCHAR szBuff[1024]; wsprintf(szBuff,TEXT("TT异常产生/r/n位置:0x%08X 异常代码:0x%08X/r/n"), pExceptionInfo->ExceptionRecord->ExceptionAddress,pExceptionInfo->ExceptionRecord->ExceptionCode); _tprintf(szBuff); MessageBox(GetForegroundWindow(),szBuff,TEXT("TTError"),0); return EXCEPTION_CONTINUE_SEARCH;//用 EXCEPTION_EXECUTE_HANDLER 将静默退出进程 //返回 EXCEPTION_CONTINUE_SEARCH 将交给windows 错误报告处理 } LONG WINAPI VectoredExceptionFilter(PEXCEPTION_POINTERS pExceptionInfo)//; //向量化异常处理程序 { //向量化异常处理程序会在seh处理程序之前被执行 //可以返回 EXCEPTION_CONTINUE_EXECUTION 让程序继续执行 //向量化异常处理程序不可以返回EXCEPTION_EXECUTE_HANDLER //返回 EXCEPTION_CONTINUE_SEARCH 让程序继续搜索下一个向量化异常处理程序 //所有向量化异常处理程序都返回了 EXCEPTION_CONTINUE_SEARCH 才会执行 seh机制 TCHAR szBuff[1024]; HMODULE hMod=ModuleFromAddress(pExceptionInfo->ExceptionRecord->ExceptionAddress); TCHAR szMod[MAX_PATH]={0}; if (hMod!=NULL) { GetModuleFileName(hMod,szMod,sizeof(szMod)); } else { lstrcpy(szMod,TEXT("Unknow Module")); } wsprintf(szBuff,TEXT("异常产生/r/n模块:/r/n%s/r/n位置:0x%08X 相对模块偏移:0x%08X 异常代码:0x%08X/r/n寄存器:/t/tEIP:%08X/r/n/ EAX:%08X/tECX:%08X/r/nEDX:%08X/tEBX:%08X/r/nESP:%08X/tEBP:%08X/r/nESI:%08X/tEDI:%08X/r/n"), szMod,pExceptionInfo->ExceptionRecord->ExceptionAddress, (int)pExceptionInfo->ExceptionRecord->ExceptionAddress-(int)hMod, pExceptionInfo->ExceptionRecord->ExceptionCode, pExceptionInfo->ContextRecord->Eip, pExceptionInfo->ContextRecord->Eax,pExceptionInfo->ContextRecord->Ecx, pExceptionInfo->ContextRecord->Edx,pExceptionInfo->ContextRecord->Ebx, pExceptionInfo->ContextRecord->Esp,pExceptionInfo->ContextRecord->Ebp, pExceptionInfo->ContextRecord->Esi,pExceptionInfo->ContextRecord->Edi); _tprintf(szBuff); MessageBox(GetForegroundWindow(),szBuff,TEXT("向量化异常处理程序"),0); return EXCEPTION_CONTINUE_SEARCH;//EXCEPTION_CONTINUE_SEARCH;//EXCEPTION_CONTINUE_EXECUTION;// EXCEPTION_EXECUTE_HANDLER; } LONG WINAPI VectoredContinueeFilter(PEXCEPTION_POINTERS pExceptionInfo)//; //继续处理程序 { //与向量化处理程序一样 只可以返回 EXCEPTION_CONTINUE_SEARCH 或者 EXCEPTION_CONTINUE_EXECUTION //继续处理程序 只有在未处理异常发生时 才接受到通知 TCHAR szBuff[1024]; HMODULE hMod=ModuleFromAddress(pExceptionInfo->ExceptionRecord->ExceptionAddress); TCHAR szMod[MAX_PATH]={0}; if (hMod!=NULL) { GetModuleFileName(hMod,szMod,sizeof(szMod)); } else { lstrcpy(szMod,TEXT("Unknow Module")); } wsprintf(szBuff,TEXT("异常产生/r/n模块:/r/n%s/r/n位置:0x%08X 相对模块偏移:0x%08X 异常代码:0x%08X/r/n寄存器:/t/tEIP:%08X/r/n/ EAX:%08X/tECX:%08X/r/nEDX:%08X/tEBX:%08X/r/nESP:%08X/tEBP:%08X/r/nESI:%08X/tEDI:%08X/r/n"), szMod,pExceptionInfo->ExceptionRecord->ExceptionAddress, (int)pExceptionInfo->ExceptionRecord->ExceptionAddress-(int)hMod, pExceptionInfo->ExceptionRecord->ExceptionCode, pExceptionInfo->ContextRecord->Eip, pExceptionInfo->ContextRecord->Eax,pExceptionInfo->ContextRecord->Ecx, pExceptionInfo->ContextRecord->Edx,pExceptionInfo->ContextRecord->Ebx, pExceptionInfo->ContextRecord->Esp,pExceptionInfo->ContextRecord->Ebp, pExceptionInfo->ContextRecord->Esi,pExceptionInfo->ContextRecord->Edi); _tprintf(szBuff); MessageBox(GetForegroundWindow(),szBuff,TEXT("继续处理程序"),0); return EXCEPTION_CONTINUE_SEARCH;//EXCEPTION_CONTINUE_SEARCH;//EXCEPTION_CONTINUE_EXECUTION;// EXCEPTION_EXECUTE_HANDLER; } void FunError(LPVOID pParam) { int n=0; __try { _tprintf(TEXT("除0错误开始/r/n")); // __try // { n=5/n;//除0错误 // } // __except(EXCEPTION_CONTINUE_SEARCH)// 改成 EXCEPTION_EXECUTE_HANDLER 就只有向量化异常有消息 // { // _tprintf(TEXT("除0错误Try/r/n")); // } _tprintf(TEXT("除0错误结束/r/n")); } __finally { //终止程序 MessageBox(GetForegroundWindow(),TEXT("I'm finally"),TEXT("finally"),NULL); } } PVOID pVectoredExceptionHandler=NULL;//向量化一次处理程序句柄 PVOID pVectoredContinueHandler=NULL;//继续处理程序句柄 int main() { pprev= SetUnhandledExceptionFilter(TopLevelUnhandledExceptionFilter);//返回上次安装的异常过滤处理函数地址 //设置 全局异常过滤程序 // SetUnhandledExceptionFilter(TopLevelUnhandledExceptionFilterT);//返回上次安装的异常过滤处理函数地址 //看起来安装两次 直接被替换成 最后一次的了 pVectoredExceptionHandler=AddVectoredExceptionHandler(0,VectoredExceptionFilter);//添加向量化异常处理程序到列表尾部 //参数1 为0 则添加到尾部 非0 添加到列表头部 向量化异常处理程序会在seh处理程序之前被执行 //可以使用 下面这个api来取消向量化异常处理程序 //RemoveVectoredExceptionHandler(pVectoredExceptionHandler); //继续处理程序 可以在未处理异常发生时得到通知! pVectoredContinueHandler=AddVectoredContinueHandler(0,VectoredContinueeFilter);//注册一个继续处理程序到尾部 //与向量化异常处理程序相似可以使用 下面这个api来取消继续处理程序 //RemoveVectoredContinueHandler(pVectoredContinueHandler); _tsetlocale(LC_CTYPE, TEXT(""));//让wprintf 支持中文 _tprintf(TEXT("begin 当前Exe模块:0x%08X %d VectoredExceptionH:%X VectoredContinueH:%d/r/n"), GetModuleHandle(NULL),IsDebuggerPresent(),pVectoredExceptionHandler,pVectoredContinueHandler); _beginthread(FunError,NULL,NULL); // Sleep(1000); _tprintf(TEXT("can here?/r/n")); int nadd=0; __try { while (1) { nadd++; _tprintf(TEXT("%d/r/n"),nadd); Sleep(500); } } __finally { //终止程序 _tprintf(TEXT("main() finally/r/n")); } _tprintf(TEXT("and here?/r/n")); return 0; } 

   
 