---
title: 文本动态随机加密  
date: 2011-01-04 14:12:00
tags: CSDN迁移
---
   #include <Windows.h> #include <atlstr.h> //可以用 cstring了 #include <stdio.h> //#pragma comment(lib,"kernel32.lib") //#pragma comment(lib,"user32.lib") //#pragma comment(linker, "/SUBSYSTEM:windows") //#pragma comment(linker, "/ENTRY:main") #ifdef _UNICODE #define TextEncrypt TextEncryptW #define TextDecryption TextDecryptionW #else #define TextEncrypt TextEncryptA #define TextDecryption TextDecryptionA #endif const CHAR m_szWord[]="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; const int m_cchWordLen=strlen(m_szWord); int MyRand(int Min,int Max)//取随机数 使用前请先调用 srand(time(NULL)); { int bychu=(int)rand(); int chu=Max-Min+1; int shang=bychu/chu; int dret=bychu-shang*chu+Min; return dret; } LPSTR TextEncryptA(LPCSTR szText,LPCSTR szKey,int cbKeyLen)//加密A 密文长度为原文长度的4倍 (返回结果 调用者 free) { if (cbKeyLen==0) { cbKeyLen=strlen(szKey); } int nTextLen=strlen(szText); int j=0,k=0; srand(GetTickCount()); int nCurPos=0; printf( "keylen:%d textlen:%d/n", cbKeyLen,nTextLen); LPSTR szRetBuff=(LPSTR)malloc(nTextLen*4+1);//调用者 free for (int i=0;i<nTextLen;i++) { if (j>=m_cchWordLen)//防止数据溢出 j=0; if (k>=cbKeyLen)//防止数据溢出 k=0; int nRandKey=MyRand(1,2500);//随机密匙 int nShang=nRandKey/m_cchWordLen;//下面两句把随机密钥分解成两个数据，一个是商，一个是余，将商乘上码表长度加上余数就是随机密匙 int nYu=nRandKey%m_cchWordLen; szRetBuff[nCurPos++]=m_szWord[nShang]; szRetBuff[nCurPos++]=m_szWord[nYu]; //临时字节 ＝ 位异或 (数据 [计数1], 码表 [计数2], 密码字节集 [计数3], 随机密匙) ' 把原数据内的对应字节这些值组合起来，形成一个新的数据 int nTmp=(byte)szText[i]^m_szWord[j]^(byte)szKey[k]^nRandKey; nTmp^=35; nShang=nTmp/m_cchWordLen;//下面两句把商数分解成两个数据，一个是商，一个是余，将商乘上码表长度加上余数就是随机密匙 nYu=nTmp%m_cchWordLen; szRetBuff[nCurPos++]=m_szWord[nShang]; szRetBuff[nCurPos++]=m_szWord[nYu]; k++; j++; } szRetBuff[nCurPos]='/0'; return szRetBuff; } LPWSTR TextEncryptW(LPCWSTR szText,LPCWSTR szKey)//宽字符版 密文长度为原文长度的4倍 (返回结果必须 调用者 free) { if (szText==NULL ||szKey==NULL) { return NULL; } int nNeed=WideCharToMultiByte(CP_ACP,0,szText,-1,NULL,0,NULL,NULL);//待加密的转换 char *const szAText=(char *const )malloc(nNeed); WideCharToMultiByte(CP_ACP,0,szText,-1,szAText,nNeed,NULL,NULL);//待加密的转换 char *const szARetBuff=(char *const )malloc(nNeed*4);//返回结果 nNeed=WideCharToMultiByte(CP_ACP,0,szKey,-1,NULL,0,NULL,NULL); char *const szAKey=(char*const)malloc(nNeed); WideCharToMultiByte(CP_ACP,0,szKey,-1,szAKey,nNeed,NULL,NULL); LPSTR szARet=TextEncryptA(szAText,szAKey,0);//调用ansi版的 nNeed=MultiByteToWideChar(CP_ACP,0,szARet,-1,NULL,0); WCHAR *szRetBuff=(WCHAR*)malloc(nNeed*sizeof(WCHAR)); MultiByteToWideChar(CP_ACP,0,szARet,-1,szRetBuff,nNeed); free(szARet);//调用者free free(szAText); free(szARetBuff); free(szAKey); return szRetBuff; } //abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 inline int GetPosByChar(char cf) { if (cf>='a' &&cf<='z') { return cf-'a'; } if (cf>='A' &&cf<='Z') { return 26+cf-'A'; } if (cf>='0'&& cf<='9') { return 26+26+cf-'0'; } return -1; } LPSTR TextDecryptionA(LPCSTR szText,LPCSTR szKey,int cbKeyLen) //返回结果由调用者free() { if (szText==NULL || szKey==NULL) { return NULL; } if (cbKeyLen==0) { cbKeyLen=strlen(szKey); } int nTextLen=strlen(szText); if (nTextLen%4!=0) { return NULL; } int j=0,k=0; srand(GetTickCount()); int nCurPos=0; printf( "keylen:%d textlen:%d/n", cbKeyLen,nTextLen); LPSTR szRetBuff=(LPSTR)malloc(nTextLen/4+1);//调用者 free for (int i=0;i<nTextLen;i+=4) { if (j>=m_cchWordLen) j=0; if (k>=cbKeyLen) k=0; //某个字节在码表中的位置就是我们要在这个位置上保存的整数。这里我们通过取出商和余就能求出那个随机密匙 int nShang=GetPosByChar(szText[i]); int nYu=GetPosByChar(szText[i+1]); if (nShang==-1 ||nYu==-1) { free(szRetBuff); return NULL; } int nRandKey=nShang*m_cchWordLen+nYu;//被除数=除数×商+余数，小学的知识 被除数就是我们保存的数据——随机密匙 nShang=GetPosByChar(szText[i+2]); nYu=GetPosByChar(szText[i+3]); if (nShang==-1 ||nYu==-1) { free(szRetBuff); return NULL; } int nTmp=nShang*m_cchWordLen+nYu; nTmp^=35; nTmp=nTmp^m_szWord[j]^szKey[k]^nRandKey; szRetBuff[nCurPos++]=(char)nTmp; j++;k++; } szRetBuff[nCurPos]='/0'; return szRetBuff; } LPWSTR TextDecryptionW(LPCWSTR szText,LPCWSTR szKey)//w版本 返回结果必须调用者free() { if (szText==NULL ||szKey==NULL) { return NULL; } int nNeed=WideCharToMultiByte(CP_ACP,0,szText,-1,NULL,0,NULL,NULL); char *const szAText=(char*const)malloc(nNeed); WideCharToMultiByte(CP_ACP,0,szText,-1,szAText,nNeed,NULL,NULL); nNeed=WideCharToMultiByte(CP_ACP,0,szKey,-1,NULL,0,NULL,NULL); char *const szAKey=(char*const)malloc(nNeed); WideCharToMultiByte(CP_ACP,0,szKey,-1,szAKey,nNeed,NULL,NULL); char *szRet=TextDecryptionA(szAText,szAKey,0); free(szAText); free(szAKey); if (szRet==NULL) { return NULL; } nNeed=MultiByteToWideChar(CP_ACP,0,szRet,-1,NULL,NULL); LPWSTR szRetBuff=(LPWSTR)malloc(nNeed*sizeof(WCHAR)); MultiByteToWideChar(CP_ACP,0,szRet,-1,szRetBuff,nNeed); free(szRet);//调用者释放 return szRetBuff; } int main() { //参考 http://bbs.eyuyan.com/read.php?tid=247112 char *szRet=TextEncryptA("老大爷你好呀", "ss你abcd",0); printf("加密结果:/n%s/n", szRet); char *szDecry=TextDecryptionA(szRet,"ss你abcd",0); printf("解密结果:/n%s/n", szDecry); free(szRet); free(szDecry); //不能忘记 free返回结果 return 0; } 

   
 